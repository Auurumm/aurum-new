// Ïã§Ï†ú Ïù∏Ï¶ù ÏãúÏä§ÌÖú Ïó∞Í≤∞
import { AuthProvider, useAuth } from './contexts/AuthContext.tsx';
import { AuthModal } from './Components/AuthModal.tsx'; 

import React, { useState, useEffect } from 'react';
import { Header } from './Components/Header/Header.tsx';
import { ProgressSection } from './Components/ProgressSection/ProgressSection.tsx';
import { CountDown } from './Components/CountDown/CountDown.tsx';
import { MainContentSection } from './Components/MainContent/MainContentSection.tsx';
import { NavigationSection} from './Components/NavigationSection/NavigationSection.tsx';
import { ReactionCardsSection } from './Components/NavigationSection/ReactionCardsSection.tsx';
import { WisdomCardGrid } from './Components/NavigationSection/CardsSection.tsx';
import { FooterSection } from './Components/Footer/FooterSection.tsx';
import './styles/index.css';
import { WisdomPost } from './services/WisdomService.ts';
import { WisdomModal } from './Components/WisdomModal.tsx';
import { supabase } from './lib/supabase.ts';

// Î©îÏù∏ Ïï± Ïª¥Ìè¨ÎÑåÌä∏ - Ïã§Ï†ú Ïù∏Ï¶ù Î°úÏßÅ ÏÇ¨Ïö©
const AppContent = () => {
  // Ïù∏Ï¶ù Í¥ÄÎ†® ÏÉÅÌÉú
  const { user, profile, signOut, loading } = useAuth();
  const [showAuthModal, setShowAuthModal] = useState(false);
  const [isSigningOut, setIsSigningOut] = useState(false);

  // ÏúÑÏ¶àÎç§ Í¥ÄÎ†® ÏÉÅÌÉú
  const [showWisdomModal, setShowWisdomModal] = useState(false);
  const [newWisdomPost, setNewWisdomPost] = useState<WisdomPost | null>(null);
  const [isWisdomCompleted, setIsWisdomCompleted] = useState(false);
  const [checkingWisdom, setCheckingWisdom] = useState(true);

  // Î∞òÏùë ÏôÑÎ£å ÏÉÅÌÉú
  const [isAllReactionsCompleted, setIsAllReactionsCompleted] = useState(false);
  const [showMotionEffect, setShowMotionEffect] = useState(false);

  // Î∑∞Ìè¨Ìä∏ ÌÅ¨Í∏∞
  const [viewportDimensions, setViewportDimensions] = useState({ width: 0, height: 0 });

  // ‚úÖ ÏÇ¨Ïö©Ïûê Î°úÍ∑∏Ïù∏ Ïãú ÏúÑÏ¶àÎç§ Ï†úÏ∂ú Ïó¨Î∂Ä ÌôïÏù∏
  useEffect(() => {
    const checkUserWisdomStatus = async () => {
      if (!user) {
        setCheckingWisdom(false);
        setIsWisdomCompleted(false);
        return;
      }

      try {
        setCheckingWisdom(true);
        console.log('üîç ÏÇ¨Ïö©Ïûê ÏúÑÏ¶àÎç§ ÏÉÅÌÉú ÌôïÏù∏ Ï§ë...', user.id);
        
        // ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÍ∞Ä ÏûëÏÑ±Ìïú ÏúÑÏ¶àÎç§ Ìè¨Ïä§Ìä∏Í∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
        const { data, error } = await supabase
          .from('wisdom_posts')
          .select('id, created_at')
          .eq('user_id', user.id)
          .maybeSingle(); // single() ÎåÄÏã† maybeSingle() ÏÇ¨Ïö© (ÏóÜÏñ¥ÎèÑ ÏóêÎü¨ ÏïàÎÇ®)

        if (error) {
          console.error('ÏúÑÏ¶àÎç§ ÌôïÏù∏ Ï§ë ÏóêÎü¨:', error);
          setIsWisdomCompleted(false);
        } else if (data) {
          // ÏúÑÏ¶àÎç§Ïù¥ Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎ©¥ ÏôÑÎ£å ÏÉÅÌÉúÎ°ú ÏÑ§Ï†ï
          console.log('‚úÖ Í∏∞Ï°¥ ÏúÑÏ¶àÎç§ Î∞úÍ≤¨ - 1Îã®Í≥Ñ ÏôÑÎ£å Ï≤òÎ¶¨', data);
          setIsWisdomCompleted(true);
        } else {
          console.log('‚ùå ÏúÑÏ¶àÎç§ ÏóÜÏùå - 1Îã®Í≥Ñ ÎØ∏ÏôÑÎ£å');
          setIsWisdomCompleted(false);
        }
      } catch (error) {
        console.error('ÏúÑÏ¶àÎç§ ÏÉÅÌÉú ÌôïÏù∏ Ïã§Ìå®:', error);
        setIsWisdomCompleted(false);
      } finally {
        setCheckingWisdom(false);
      }
    };
    
    checkUserWisdomStatus();
  }, [user]);
  
  // ‚úÖ Ï∂îÍ∞Ä: ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Î∞òÏùë ÏôÑÎ£å ÏÉÅÌÉú ÌôïÏù∏
  useEffect(() => {
    const checkReactionCompletion = async () => {
      if (!user) {
        setIsAllReactionsCompleted(false);
        return;
      }
  
      try {
        console.log('üîç Î∞òÏùë ÏôÑÎ£å ÏÉÅÌÉú ÌôïÏù∏ Ï§ë...', user.id);
        
        // WisdomServiceÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Î∞òÏùë Í∞úÏàò ÌôïÏù∏
        const { data: reactionData, error } = await supabase
          .from('user_reactions')
          .select('honor_sent, recommend_sent, respect_sent, hug_sent')
          .eq('user_id', user.id)
          .maybeSingle();
  
        if (error) {
          console.error('Î∞òÏùë ÌôïÏù∏ Ïò§Î•ò:', error);
          return;
        }
  
        if (reactionData) {
          const totalReactions = 
            (reactionData.honor_sent || 0) + 
            (reactionData.recommend_sent || 0) + 
            (reactionData.respect_sent || 0) + 
            (reactionData.hug_sent || 0);
  
          console.log('Ï¥ù Î∞òÏùë Í∞úÏàò:', totalReactions);
  
          // ‚úÖ 12Í∞ú Ïù¥ÏÉÅÏù¥Î©¥ ÏôÑÎ£å ÏÉÅÌÉúÎ°ú ÏÑ§Ï†ï
          if (totalReactions >= 12) {
            console.log('‚úÖ Î∞òÏùë 12Í∞ú ÏôÑÎ£å - ProgressBar3 ÌëúÏãú');
            setIsAllReactionsCompleted(true);
          }
        }
      } catch (error) {
        console.error('Î∞òÏùë ÏôÑÎ£å ÏÉÅÌÉú ÌôïÏù∏ Ïã§Ìå®:', error);
      }
    };
  
    checkReactionCompletion();
  }, [user]);

  // Î∑∞Ìè¨Ìä∏ ÌÅ¨Í∏∞ Ï∂îÏ†Å
  useEffect(() => {
    const updateViewportDimensions = () => {
      setViewportDimensions({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    updateViewportDimensions();
    window.addEventListener('resize', updateViewportDimensions);
    
    document.body.style.height = 'auto';
    document.body.style.minHeight = '100vh';
    document.body.style.overflow = 'visible';
    
    return () => {
      window.removeEventListener('resize', updateViewportDimensions);
    };
  }, []);

  // Î™®Îì† Î∞òÏùë ÏôÑÎ£å Ï≤òÎ¶¨
  const handleAllReactionsComplete = () => {
    console.log('üî• App.tsx - handleAllReactionsComplete Ìò∏Ï∂úÎê®!');
    console.log('Ïù¥Ï†Ñ ÏÉÅÌÉú:', { isWisdomCompleted, isAllReactionsCompleted, showMotionEffect });
    
    setIsAllReactionsCompleted(true);
    setShowMotionEffect(true);
    
    console.log('ÏÉÅÌÉú Î≥ÄÍ≤Ω ÏôÑÎ£å - Î™®ÏÖò Ìö®Í≥º ÏãúÏûë');
    
    setTimeout(() => {
      console.log('10Ï¥à ÌõÑ Î™®ÏÖò Ìö®Í≥º Ï†úÍ±∞');
      setShowMotionEffect(false);
    }, 10000);
  };

  // Ïù∏Ï¶ùÏù¥ ÌïÑÏöîÌïú Ïï°ÏÖò Ï≤òÎ¶¨
  const handleAuthRequired = () => {
    if (!user) {
      setShowAuthModal(true);
      return false;
    }
    return true;
  };

  // Í∞úÏÑ†Îêú Î°úÍ∑∏ÏïÑÏõÉ Ï≤òÎ¶¨
  const handleSignOut = async () => {
    if (isSigningOut) return;
    
    setIsSigningOut(true);
    console.log('üö™ Î°úÍ∑∏ÏïÑÏõÉ ÏãúÏûë...');
    
    try {
      const { error } = await signOut();
      
      if (error) {
        console.error('‚ùå Î°úÍ∑∏ÏïÑÏõÉ Ïã§Ìå®:', error);
        alert('Î°úÍ∑∏ÏïÑÏõÉ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
      } else {
        console.log('‚úÖ Î°úÍ∑∏ÏïÑÏõÉ ÏÑ±Í≥µ');
        
        // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        setShowAuthModal(false);
        setIsWisdomCompleted(false);
        setIsAllReactionsCompleted(false);
        setShowMotionEffect(false);
        
        // ÌéòÏù¥ÏßÄ ÏÉàÎ°úÍ≥†Ïπ®ÏúºÎ°ú ÌôïÏã§Ìïú ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        setTimeout(() => {
          window.location.replace(window.location.origin);
        }, 200);
      }
    } catch (error) {
      console.error('‚ùå Î°úÍ∑∏ÏïÑÏõÉ ÏòàÏô∏:', error);
      alert('Î°úÍ∑∏ÏïÑÏõÉ Ï§ë ÏòàÏÉÅÏπò Î™ªÌïú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    } finally {
      setIsSigningOut(false);
    }
  };

  // Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä ÎßàÏö¥Ìä∏Îê† Îïå CSS Ïä§ÌÉÄÏùº Ï∂îÍ∞Ä
  useEffect(() => {
    const style = document.createElement('style');
    style.textContent = `
      .motion-effect {
        position: relative;
        overflow: hidden;
      }
      
      .star-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 10;
      }
    `;
    document.head.appendChild(style);

    return () => {
      if (document.head.contains(style)) {
        document.head.removeChild(style);
      }
    };
  }, []);

  // Î≥Ñ Îñ®Ïñ¥ÏßÄÎäî Ìö®Í≥º
  useEffect(() => {
    if (!showMotionEffect) return;

    const canvas = document.createElement('canvas');
    canvas.className = 'star-canvas';
    
    const motionElement = document.querySelector('.motion-effect');
    if (!motionElement) return;
    
    motionElement.appendChild(canvas);
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    let animationId: number;
    
    const resizeCanvas = () => {
      const rect = motionElement.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
    };
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    const size = [15, 40];
    const shineDir = [0.02, 0.08];
    const angSpeed = [0.02, 0.06];
    
    interface StarType {
      size: number;
      x: number;
      y: number;
      vy: number;
      vx: number;
      ay: number;
      shine: number;
      shineDir: number;
      color: string;
      rot: number;
      omega: number;
      use(): void;
    }
    
    const stars: StarType[] = [];
    let frame = (Math.random() * 360) | 0;
    const pentaRadiant = Math.PI * 2 / 5;
    
    function rand(ar: number[]): number {
      return Math.random() * (ar[1] - ar[0]) + ar[0];
    }
    
    function Star(this: StarType) {
      this.size = rand(size);
      this.x = Math.random() * canvas.width;
      this.y = -this.size * 2;
      this.vy = this.size / 8;
      this.vx = Math.random() * 4 - 2;
      this.ay = this.size / 3000;
      this.shine = 0;
      this.shineDir = rand(shineDir);
      this.color = `hsla(${(frame % 360)}, 80%, 60%, 0.8)`;
      this.rot = Math.random() * 2 * Math.PI;
      this.omega = rand(angSpeed);
      if (Math.random() < 0.5) this.omega *= -1;
    }
    
    Star.prototype.use = function(this: StarType) {
      if (!ctx) return;
      
      this.x += this.vx;
      this.y += this.vy += this.ay;
      
      const newShine = this.shine + this.shineDir;
      if (newShine < 0 || newShine > 1) this.shineDir *= -1;
      else this.shine = newShine;
      this.rot += this.omega;
      
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rot);
      ctx.fillStyle = this.color.replace('60%', `${(30 + this.shine * 40)}%`);
      ctx.beginPath();
      ctx.moveTo(this.size, 0);
      
      for (let i = 0; i < 5; ++i) {
        const rad = pentaRadiant * i;
        const halfRad = rad + pentaRadiant / 2;
        ctx.lineTo(Math.cos(rad) * this.size, Math.sin(rad) * this.size);
        ctx.lineTo(Math.cos(halfRad) * this.size / 2, Math.sin(halfRad) * this.size / 2);
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    };
    
    function animate() {
      if (!ctx) return;
      
      frame++;
      
      ctx.globalCompositeOperation = 'destination-out';
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'lighter';
      
      if (Math.random() < 0.4) {
        const newStar = new (Star as any)() as StarType;
        stars.push(newStar);
      }
      
      for (let s = stars.length - 1; s >= 0; s--) {
        stars[s].use();
        
        if (stars[s].y > canvas.height + stars[s].size || 
            stars[s].x < -stars[s].size || 
            stars[s].x > canvas.width + stars[s].size) {
          stars.splice(s, 1);
        }
      }
      
      animationId = requestAnimationFrame(animate);
    }
    
    animate();
    
    const cleanup = setTimeout(() => {
      if (animationId) cancelAnimationFrame(animationId);
      window.removeEventListener('resize', resizeCanvas);
      if (canvas.parentNode) {
        canvas.parentNode.removeChild(canvas);
      }
    }, 10000);
    
    return () => {
      if (animationId) cancelAnimationFrame(animationId);
      window.removeEventListener('resize', resizeCanvas);
      clearTimeout(cleanup);
      if (canvas.parentNode) {
        canvas.parentNode.removeChild(canvas);
      }
    };
  }, [showMotionEffect, viewportDimensions]);

  // ÏúÑÏ¶àÎç§ Ï†úÏ∂ú Ï≤òÎ¶¨
  const handleWisdomSubmitted = (wisdomPost: WisdomPost) => {
    console.log('‚úÖ ÏÉà ÏúÑÏ¶àÎç§ Ìè¨Ïä§Ìä∏ Î∞õÏùå:', wisdomPost);
    setNewWisdomPost(wisdomPost);
    setShowWisdomModal(false);
    setIsWisdomCompleted(true); // ‚úÖ Ï†úÏ∂ú Ï¶âÏãú ÏôÑÎ£å ÏÉÅÌÉúÎ°ú
    
    // Ïû†Ïãú ÌõÑ nullÎ°ú Î¶¨ÏÖãÌïòÏó¨ Ï§ëÎ≥µ Ï∂îÍ∞Ä Î∞©ÏßÄ
    setTimeout(() => setNewWisdomPost(null), 100);
  };

  // ‚úÖ Î°úÎî© Ï§ëÏùº Îïå (Ïù∏Ï¶ù Î°úÎî© ÎòêÎäî ÏúÑÏ¶àÎç§ ÌôïÏù∏ Ï§ë)
  if (loading || checkingWisdom) {
    return (
      <div className="w-full min-h-screen bg-gradient-to-b from-[#111410] to-black flex items-center justify-center">
        <div className="text-white text-xl">Î°úÎî© Ï§ë...</div>
      </div>
    );
  }

  return (
    <div 
      className="w-full min-h-screen bg-gradient-to-b from-[#111410] to-black"
      style={{
        minHeight: '100vh',
        position: 'relative',
        display: 'flex',
        flexDirection: 'column',
      }}
    >
      {/* Î∞òÏùëÌòï Ïª®ÌÖåÏù¥ÎÑà */}
      <div 
        className="w-full flex-1 flex flex-col"
        style={{
          maxWidth: '100vw',
          overflow: 'hidden',
        }}
      >
        {/* Ìó§Îçî */}
        <div className="w-full relative z-20">
          <Header 
            onLoginClick={() => setShowAuthModal(true)}
            onLogoutClick={handleSignOut}
          />
        </div>
        
        {/* Î©îÏù∏ ÏΩòÌÖêÏ∏† ÏòÅÏó≠ */}
        <div className="w-full flex-1 transition-all duration-1000 relative">
          {/* ProgressSectionÏùÑ motion-effectÎ°ú Í∞êÏã∏Í∏∞ */}
          <div className={`relative ${showMotionEffect ? 'motion-effect' : ''}`}>
            <ProgressSection 
              isCompleted={isWisdomCompleted} 
              isAllReactionsCompleted={isAllReactionsCompleted}
            />
          </div>
          
          <div id="countdown-section" className="w-full">
            <CountDown 
              isCompleted={isWisdomCompleted}
              onComplete={() => setIsWisdomCompleted(true)}
            />
          </div>

          <MainContentSection />

          <div id="navigation-section" className="w-full">
            <NavigationSection isAllReactionsCompleted={isAllReactionsCompleted} />
          </div>
          
          <ReactionCardsSection />
          
          <WisdomCardGrid 
            isWisdomCompleted={isWisdomCompleted}
            onAllReactionsComplete={handleAllReactionsComplete}
            newWisdomPost={newWisdomPost}
            requireAuth={true}
            onAuthRequired={handleAuthRequired}
          />
        </div>
        
        {/* Ìë∏ÌÑ∞ */}
        <div className="w-full mt-auto relative z-20">
          <FooterSection />
        </div>
      </div>

      {/* Ïã§Ï†ú Ïù∏Ï¶ù Î™®Îã¨ */}
      <AuthModal 
        isOpen={showAuthModal}
        onClose={() => setShowAuthModal(false)}
      />

      {/* ÏúÑÏ¶àÎç§ ÏûëÏÑ± Î™®Îã¨ */}
      <WisdomModal
        isOpen={showWisdomModal}
        onClose={() => setShowWisdomModal(false)}
        onWisdomSubmitted={handleWisdomSubmitted}
        isLoggedIn={!!user}
      />
    </div>
  );
};

// Ïã§Ï†ú AuthProviderÎ°ú Í∞êÏã∏Í∏∞
const App = () => {
  return (
    <AuthProvider>
      <AppContent />
    </AuthProvider>
  );
};

export default App;